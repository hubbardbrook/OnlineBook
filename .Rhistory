library(tidyr)
head(see)
see<-gather( seeds, "Type","Value",2:10)
# Save plot 4
plot4 <- ggplot(seeds, aes(x=YEAR, y=FAGR_diff)) +
geom_bar(stat="identity",  fill="gray", col="black") +
geom_hline(yintercept = sd(seeds$FAGR_diff,  na.rm=TRUE), linetype="dashed")+
labs(x = "Year", y = ("FAGR ASD"))+
theme_classic()
plot4
# Save plot 5
plot5 <- ggplot(seeds, aes(x=YEAR, y=ACSA_diff)) +
geom_bar(stat="identity",fill="black") +
geom_hline(yintercept = sd(seeds$ACSA_diff, na.rm=T), linetype="dashed")+
labs(x = "Year", y = ("ACSA ASD"))+
theme_classic()
plot5
# Save plot 6
plot6 <- ggplot(seeds, aes(x=YEAR, y=FRAM_diff)) +
geom_bar(stat="identity") +
geom_hline(yintercept = sd(seeds$FRAM_diff, na.rm=TRUE), linetype="dashed")+
labs(x = "Year", y = ("FRAM deviation"))+
theme_classic()
plot6
## form the plotly graphs
p1<-ggplotly(plot1)
p2<-ggplotly(plot2)
p4<-ggplotly(plot4)
p5<-ggplotly(plot5)
# %>%
#   layout(title = list(text = paste0('Fig. 1. Seed production for sugar maple (ACSA) and American beech
# (FAGR) at Hubbard Brook Experimental Forest, New Hampshire',
#                                     '<br>',
#                                     '<sup>',
#                                     'Hover over figure to view values, and to access zoom, pan, download, and other controls."',
#                                     '</sup>')))
p5
plotfinal<-subplot(p2, p1, p5, p4, nrows=4,
shareX = FALSE, titleY=TRUE,margin=0.01)
plotfinal
# this line writes the html file to create interactive graphs for the online book
htmlwidgets::saveWidget(as_widget(plotfinal), "ForestComposition_Dynamics/fig7_ACSA_FAGR_seeds.html")
#Use the libraries
library("plyr")
library("ggplot2")
library("ggplotify")
library("cowplot")
library("grid")
library("gridExtra")
library(plotly)
#Download streamflow data by watershed
inUrl1  <- "https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/2/11/1254d17cbd381556c05afa740d380e78"
infile1 <- tempfile()
try(download.file(inUrl1,infile1,method="curl"))
if (is.na(file.size(infile1))) download.file(inUrl1,infile1,method="auto")
dt1 <-read.csv(infile1,header=F
,skip=1
,sep=","
,quot='"'
, col.names=c(
"DATE",
"WS",
"Streamflow",
"Flag"    ), check.names=TRUE)
unlink(infile1)
# attempting to convert dt1$DATE dateTime string to R date structure (date or POSIXct)
tmpDateFormat<-"%Y-%m-%d"
tmp1DATE<-as.Date(dt1$DATE,format=tmpDateFormat)
# Keep the new dates only if they all converted correctly
if(length(tmp1DATE) == length(tmp1DATE[!is.na(tmp1DATE)])){dt1$DATE <- tmp1DATE } else {print("Date conversion failed for dt1$DATE. Please inspect the data and do the date conversion yourself.")}
rm(tmpDateFormat,tmp1DATE)
if (class(dt1$WS)!="factor") dt1$WS<- as.factor(dt1$WS)
if (class(dt1$Streamflow)=="factor") dt1$Streamflow <-as.numeric(levels(dt1$Streamflow))[as.integer(dt1$Streamflow) ]
if (class(dt1$Streamflow)=="character") dt1$Streamflow <-as.numeric(dt1$Streamflow)
if (class(dt1$Flag)=="factor") dt1$Flag <-as.numeric(levels(dt1$Flag))[as.integer(dt1$Flag) ]
if (class(dt1$Flag)=="character") dt1$Flag <-as.numeric(dt1$Flag)
# Convert Missing Values to NA for non-dates
dt1$Flag <- ifelse((trimws(as.character(dt1$Flag))==trimws("NA")),NA,dt1$Flag)
suppressWarnings(dt1$Flag <- ifelse(!is.na(as.numeric("NA")) & (trimws(as.character(dt1$Flag))==as.character(as.numeric("NA"))),NA,dt1$Flag))
streamflow <- dt1
#Download precipitation data by watershed
inUrl1  <- "https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/14/14/c606bfe2f2deb3fa3eabf692ae15f02d"
infile1 <- tempfile()
try(download.file(inUrl1,infile1,method="curl"))
if (is.na(file.size(infile1))) download.file(inUrl1,infile1,method="auto")
dt1 <-read.csv(infile1,header=F
,skip=1
,sep=","
, col.names=c(
"DATE",
"watershed",
"Precip"    ), check.names=TRUE)
unlink(infile1)
# attempting to convert dt1$DATE dateTime string to R date structure (date or POSIXct)
tmpDateFormat<-"%Y-%m-%d"
tmp1DATE<-as.Date(dt1$DATE,format=tmpDateFormat)
# Keep the new dates only if they all converted correctly
if(length(tmp1DATE) == length(tmp1DATE[!is.na(tmp1DATE)])){dt1$DATE <- tmp1DATE } else {print("Date conversion failed for dt1$DATE. Please inspect the data and do the date conversion yourself.")}
rm(tmpDateFormat,tmp1DATE)
if (class(dt1$watershed)!="factor") dt1$watershed<- as.factor(dt1$watershed)
if (class(dt1$Precip)=="factor") dt1$Precip <-as.numeric(levels(dt1$Precip))[as.integer(dt1$Precip) ]
if (class(dt1$Precip)=="character") dt1$Precip <-as.numeric(dt1$Precip)
precipitation <- dt1
colnames(precipitation) <- c("date","watershed","precip_mm")
streamflow$Flag <- NULL
colnames(streamflow) <- c("date","watershed","strflow_mm")
precipitation$watershed <- as.character(precipitation$watershed)
precipitation$watershed[(precipitation$watershed == "W1")] <- 1
precipitation$watershed[(precipitation$watershed == "W2")] <- 2
precipitation$watershed[(precipitation$watershed == "W3")] <- 3
precipitation$watershed[(precipitation$watershed == "W4")] <- 4
precipitation$watershed[(precipitation$watershed == "W5")] <- 5
precipitation$watershed[(precipitation$watershed == "W6")] <- 6
precipitation$watershed[(precipitation$watershed == "W7")] <- 7
precipitation$watershed[(precipitation$watershed == "W8")] <- 8
precipitation$watershed[(precipitation$watershed == "W9")] <- 9
waterbudget <- merge(streamflow,precipitation, by = c("date", "watershed"), all = FALSE)
temp_date <- waterbudget$date
year <- substr(temp_date,1,4)
year <- as.matrix(year)
month <-  substr(temp_date,6,7)
month <- as.matrix(month)
year_month <- paste(year,month,sep="-")
year_month <- as.matrix(year_month)
# water year June 1st - May 31st
# assign water year depending if month < 6
water_year <- function(year,month)
{
tYear <- as.numeric(year)
tMon <- as.numeric(month)
WYear <- ifelse(tMon<6,tYear-1,tYear)
return (WYear)
}
wy <- water_year(year,month)
wy <- as.matrix(wy)
waterbudget <- cbind(waterbudget,wy)
waterbudget_W1 <- subset(waterbudget,(watershed==1))
waterbudget_W2 <- subset(waterbudget,(watershed==2))
waterbudget_W3 <- subset(waterbudget,(watershed==3))
waterbudget_W4 <- subset(waterbudget,(watershed==4))
waterbudget_W5 <- subset(waterbudget,(watershed==5))
waterbudget_W6 <- subset(waterbudget,(watershed==6))
waterbudget_W7 <- subset(waterbudget,(watershed==7))
waterbudget_W8 <- subset(waterbudget,(watershed==8))
waterbudget_W9 <- subset(waterbudget,(watershed==9))
waterbudget_W1$watershed <- NULL
waterbudget_W2$watershed <- NULL
waterbudget_W3$watershed <- NULL
waterbudget_W4$watershed <- NULL
waterbudget_W5$watershed <- NULL
waterbudget_W6$watershed <- NULL
waterbudget_W7$watershed <- NULL
waterbudget_W8$watershed <- NULL
waterbudget_W9$watershed <- NULL
colnames(waterbudget_W1) <- c("date","strflow_mm_W1", "precip_mm_W1","wy")
colnames(waterbudget_W2) <- c("date","strflow_mm_W2", "precip_mm_W2","wy")
colnames(waterbudget_W3) <- c("date","strflow_mm_W3", "precip_mm_W3","wy")
colnames(waterbudget_W4) <- c("date","strflow_mm_W4", "precip_mm_W4","wy")
colnames(waterbudget_W5) <- c("date","strflow_mm_W5", "precip_mm_W5","wy")
colnames(waterbudget_W6) <- c("date","strflow_mm_W6", "precip_mm_W6","wy")
colnames(waterbudget_W7) <- c("date","strflow_mm_W7", "precip_mm_W7","wy")
colnames(waterbudget_W8) <- c("date","strflow_mm_W8", "precip_mm_W8","wy")
colnames(waterbudget_W9) <- c("date","strflow_mm_W9", "precip_mm_W9","wy")
WY_day_count_W1 <- count(waterbudget_W1, "wy")
keep_wy_W1 <- subset(WY_day_count_W1,(freq>=365))
waterbudget_W1_merge <- merge(waterbudget_W1,keep_wy_W1, by = c("wy"))
waterbudget_W1_merge$freq <- NULL
WY_day_count_W2 <- count(waterbudget_W2, "wy")
keep_wy_W2 <- subset(WY_day_count_W2,(freq>=365))
waterbudget_W2_merge <- merge(waterbudget_W2,keep_wy_W2, by = c("wy"))
waterbudget_W2_merge$freq <- NULL
WY_day_count_W3 <- count(waterbudget_W3, "wy")
keep_wy_W3 <- subset(WY_day_count_W3,(freq>=365))
waterbudget_W3_merge <- merge(waterbudget_W3,keep_wy_W3, by = c("wy"))
waterbudget_W3_merge$freq <- NULL
WY_day_count_W4 <- count(waterbudget_W4, "wy")
keep_wy_W4 <- subset(WY_day_count_W4,(freq>=365))
waterbudget_W4_merge <- merge(waterbudget_W4,keep_wy_W4, by = c("wy"))
waterbudget_W4_merge$freq <- NULL
WY_day_count_W5 <- count(waterbudget_W5, "wy")
keep_wy_W5 <- subset(WY_day_count_W5,(freq>=365))
waterbudget_W5_merge <- merge(waterbudget_W5,keep_wy_W5, by = c("wy"))
waterbudget_W5_merge$freq <- NULL
WY_day_count_W6 <- count(waterbudget_W6, "wy")
keep_wy_W6 <- subset(WY_day_count_W6,(freq>=365))
waterbudget_W6_merge <- merge(waterbudget_W6,keep_wy_W6, by = c("wy"))
waterbudget_W6_merge$freq <- NULL
WY_day_count_W7 <- count(waterbudget_W7, "wy")
keep_wy_W7 <- subset(WY_day_count_W7,(freq>=365))
waterbudget_W7_merge <- merge(waterbudget_W7,keep_wy_W7, by = c("wy"))
waterbudget_W7_merge$freq <- NULL
WY_day_count_W8 <- count(waterbudget_W8, "wy")
keep_wy_W8 <- subset(WY_day_count_W8,(freq>=365))
waterbudget_W8_merge <- merge(waterbudget_W8,keep_wy_W8, by = c("wy"))
waterbudget_W8_merge$freq <- NULL
WY_day_count_W9 <- count(waterbudget_W9, "wy")
keep_wy_W9 <- subset(WY_day_count_W9,(freq>=365))
waterbudget_W9_merge <- merge(waterbudget_W9,keep_wy_W9, by = c("wy"))
waterbudget_W9_merge$freq <- NULL
wb <- merge(waterbudget_W1_merge,waterbudget_W2_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W3_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W4_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W5_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W6_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W7_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W8_merge, by = c("date","wy"), all = TRUE)
wb <- merge(wb,waterbudget_W9_merge, by = c("date","wy"), all = TRUE)
wb$date <- NULL
wb_wy <- aggregate(wb, by=list(wb$wy), FUN = sum)
wb_wy$wy <- NULL
names(wb_wy)[names(wb_wy) == "Group.1"] <- "wy"
wb_wy$et_mm_W1 <- wb_wy$precip_mm_W1 - wb_wy$strflow_mm_W1
wb_wy$et_mm_W2 <- wb_wy$precip_mm_W2 - wb_wy$strflow_mm_W2
wb_wy$et_mm_W3 <- wb_wy$precip_mm_W3 - wb_wy$strflow_mm_W3
wb_wy$et_mm_W4 <- wb_wy$precip_mm_W4 - wb_wy$strflow_mm_W4
wb_wy$et_mm_W5 <- wb_wy$precip_mm_W5 - wb_wy$strflow_mm_W5
wb_wy$et_mm_W6 <- wb_wy$precip_mm_W6 - wb_wy$strflow_mm_W6
wb_wy$et_mm_W7 <- wb_wy$precip_mm_W7 - wb_wy$strflow_mm_W7
wb_wy$et_mm_W8 <- wb_wy$precip_mm_W8 - wb_wy$strflow_mm_W8
wb_wy$et_mm_W9 <- wb_wy$precip_mm_W9 - wb_wy$strflow_mm_W9
wb_wy <-
wb_wy[c("wy","precip_mm_W1","strflow_mm_W1","et_mm_W1",
"precip_mm_W2","strflow_mm_W2","et_mm_W2",
"precip_mm_W3","strflow_mm_W3","et_mm_W3",
"precip_mm_W4","strflow_mm_W4","et_mm_W4",
"precip_mm_W5","strflow_mm_W5","et_mm_W5",
"precip_mm_W6","strflow_mm_W6","et_mm_W6",
"precip_mm_W7","strflow_mm_W7","et_mm_W7",
"precip_mm_W8","strflow_mm_W8","et_mm_W8",
"precip_mm_W9","strflow_mm_W9","et_mm_W9")]
head(wb_wy,5)
#########  Alex Y stepped in here to re-structure the dataframe
# gather the data frame to make each watershed be identified in a column
library(tidyr)
head(wb_wy)
names(wb_wy)
wb<-gather(wb_wy, "Var_ID","value", 2:28)
head(wb)
table(wb$Var_ID,wb$wy)
dim(wb)
# After gathering by the columns of et, precip, and strflow,Extract the variable ID and Watershed ID from the string
wb$vars <- substr(wb$Var_ID, 1, 5)  # extract the first three characters
wb[wb$vars=="preci","Variable"]<-"Precipitation"   # clean up the column after parsing it
wb[wb$vars=="et_mm","Variable"]<-"Evapotranspiration"
wb[wb$vars=="strfl","Variable"]<-"Streamflow"
head(wb)
n_last <- 2    # Specify number of characters to extract
wb$Watershed<-substr(wb$Var_ID, nchar(wb$Var_ID) - n_last + 1, nchar(wb$Var_ID)) # Extract last three characters
table(wb$Watershed, wb$wy)
table(wb$wy, wb$Watershed)
####################################################
## set your max and min values so the axes will continually scale
maxval <- max(c(wb$value), na.rm=TRUE)
minval <- min(c(wb$value), na.rm=TRUE)
maxval
minval
# order the variables in the way they show on the graph
table(wb$Variable)
table(wb$wy)
wb$Variable <- factor(wb$Variable, levels=c("Precipitation","Streamflow","Evapotranspiration"))
table(wb$Watershed, wb$wy)
head(wb)
# if you just want to show 4 panels
str(wb)
wb$Watershed<-as.factor(wb$Watershed)
wa3<-wb[wb$Watershed==c("W3"),]
wa6<-wb[wb$Watershed==c("W6"),]
wa7<-wb[wb$Watershed==c("W7"),]
wa8<-wb[wb$Watershed==c("W8"),]
wbj<-rbind(wa3, wa6, wa7, wa8)
W <- ggplot(data = wbj ,aes(x = wy, y= value, col= Variable)) +
geom_line() +
geom_point()+
geom_smooth(method="lm", se=F, fullrange=F)+
scale_color_manual(values=c("dark grey","blue","forest green"))+
xlab("Water year (June 1)")+  ylab("Water (mm)")+
theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
#scale_y_continuous(limits = c(floor(minval/250)*250, ceiling(maxval/250)*250), expand = c(0,0), breaks=seq(floor(minval/250)*250,ceiling(maxval/250)*250,250)) +
#scale_x_continuous(limits = c(1955, round(max(wb_wy$wy),-1)+5), expand = c(0,0), breaks=seq(1955,round(max(wb_wy$wy),-1)+5,10))+
facet_wrap(~Watershed)+
theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1), legend.position = "bottom", legend.title = element_blank())
W
W <- ggplotly(W,  margin=0.05, nrows=3, shareY=TRUE, shareX=TRUE) %>%
layout(legend = list(orientation = 'h', x = -.05, y = -.2))
W
# this line writes the html file to create interactive graphs for the online book
htmlwidgets::saveWidget(as_widget(W), "Hydrology/fig2_precip_stream_evapotranspiration.html")
rm(list = ls())
#Use the libraries
library("tidyr")
library("lubridate")
library("dplyr")
library("ggplot2")
library("trend")
library("zoo")
library("ggplotify")
library("egg")
library("cowplot")
library("grid")
library("gridExtra")
library("ggpmisc")
library(plotly)
# load data from EDI:
# Package ID: knb-lter-hbr.27.16 Cataloging System:https://pasta.edirepository.org.
# Data set title: Hubbard Brook Experimental Forest: Weekly Snow and Frost Measurements, 1955 - present.
# Data set creator:    - USDA Forest Service, Northern Research Station
# Contact:    -  Hubbard Brook Ecosystem Study  - hbr-im@lternet.edu
# Stylesheet v2.11 for metadata conversion into program: John H. Porter, Univ. Virginia, jporter@virginia.edu
inUrl1  <- "https://pasta.lternet.edu/package/data/eml/knb-lter-hbr/27/16/e9dc11e1518fb5820e614dc512a2517d"
infile1 <- tempfile()
try(download.file(inUrl1,infile1,method="curl"))
if (is.na(file.size(infile1))) download.file(inUrl1,infile1,method="auto")
dat <-read.csv(infile1, stringsAsFactors=F, na.strings = -99)
unlink(infile1)
#format date
dat$Date <- as.Date(dat$Date)
#take a peek at the df
str(dat)
summary(dat)
#select only current snowcourses and drop rows with NA snow_depth
current_sc <- c("STA19","STA2","STAHQ","STA17","STA9")
depthDat <- dat %>%
filter(Site %in% current_sc) %>%
select(c(WINTER, Date, Site, snow_depth, swe)) %>%
drop_na() %>%
dplyr::distinct()
#Calculate snowpack duration and max snow depth in a nested loop:
#set up vectors to hold the output:
winter <- vector(length=0)
site <- vector(length=0)
first_date <- vector(length=0)
last_date <- vector(length=0)
first_depth <- vector(length=0)
last_depth <- vector(length=0)
max_depth <- vector(length=0)
max_swe <- vector(length=0)
sites <- unique(depthDat$Site)
for (i in seq_along(sites)){
temp <- subset(depthDat, Site == sites[i])
winters <- unique(temp$WINTER)
for(j in seq_along(winters)){
temp2 <- subset(temp, WINTER == winters[j])
#code depth as binary (0/1 = no/yes)
cutoff <- 0
temp2$snow_depth_binary <- ifelse(temp2$snow_depth <= cutoff, 0, 1)
#run length encoding, change everything but the longest run to 0, then expand the edited rle back to a vector
RLE <- rle(temp2$snow_depth_binary)
RLE$values[RLE$lengths!=max(RLE$lengths[RLE$values==1])] <- 0
temp2$test <- inverse.rle(RLE)
#select only the dates of snowpack duration:
temp3 <- subset(temp2, temp2$test == 1)
#append info to output vectors
winter <- append(winter, winters[j])
site <- append(site, sites[i])
first_date <- append(first_date,as.character(temp3$Date[1]))
first_depth <- append(first_depth, temp3$snow_depth[1])
last_date <- append(last_date,as.character(temp3$Date[length(temp3$Date)]))
last_depth <- append(last_depth, temp3$snow_depth[length(temp3$Date)])
max_depth <- append(max_depth, max(temp3$snow_depth))
max_swe <- append(max_swe, max(temp3$swe))
}
}
#create dataframe of output
out1 <- as.data.frame(cbind(winter, site, max_depth, max_swe, first_date, first_depth, last_date, last_depth), stringsAsFactors=F)
out1$winter <- as.numeric(out1$winter)
out1$max_depth <- as.numeric(out1$max_depth)
out1$max_swe <- as.numeric(out1$max_swe)
out1$first_date <- as.Date(out1$first_date)
out1$first_depth <- as.numeric(out1$first_depth)
out1$last_date <- as.Date(out1$last_date)
out1$last_depth <- as.numeric(out1$last_depth)
#calculate duration
out1$duration <- out1$last_date-out1$first_date + 7 #add 7 days to match how John defined duration in 2015 paper
out1$duration <- as.numeric(out1$duration)
#convert to cm
out1$max_depth <- out1$max_depth/10
out1$max_swe <- out1$max_swe/10
out <- subset(out1, site == "STA2", select = c("winter","site","max_depth","max_swe","duration"))
max_depth_sen <- sens.slope(out$max_depth, conf.level = 0.95)
max_depth_sen
out$max_depth_slp <- NA
out$max_depth_slp[1] <- median(out$max_depth)-
(((nrow(out)-1)/2)*max_depth_sen$estimate)
out$max_depth_slp[nrow(out)] <- median(out$max_depth)+
(((nrow(out)-1)/2)*max_depth_sen$estimate)
out$max_depth_slp <-
c(na.approx(out$max_depth_slp))
length(out$max_depth_slp)*max_depth_sen$estimate
max_swe_sen <- sens.slope(out$max_swe, conf.level = 0.95)
max_swe_sen
out$max_swe_slp <- NA
out$max_swe_slp[1] <- median(out$max_swe)-
(((nrow(out)-1)/2)*max_swe_sen$estimate)
out$max_swe_slp[nrow(out)] <- median(out$max_swe)+
(((nrow(out)-1)/2)*max_swe_sen$estimate)
out$max_swe_slp <-
c(na.approx(out$max_swe_slp))
length(out$max_swe_slp)*max_swe_sen$estimate
duration_sen <- sens.slope(out$duration, conf.level = 0.95)
duration_sen
out$duration_slp <- NA
out$duration_slp[1] <- median(out$duration)-
(((nrow(out)-1)/2)*duration_sen$estimate)
out$duration_slp[nrow(out)] <- median(out$duration)+
(((nrow(out)-1)/2)*duration_sen$estimate)
out$duration_slp <-
c(na.approx(out$duration_slp))
length(out$duration_slp)*duration_sen$estimate
snow_depth_yr_count <- sum(sapply(out$max_depth, function(x) sum(!is.na(x))))
snow_depth_slp_time <- max_depth_sen$estimates * snow_depth_yr_count
snow_depth_sen_slp <- round(snow_depth_slp_time, digits=0)
snow_depth_sen_p <- round(max_depth_sen$p.value, digits=3)
swe_yr_count <- sum(sapply(out$max_swe, function(x) sum(!is.na(x))))
swe_slp_time <- max_swe_sen$estimates * swe_yr_count
swe_sen_slp <- round(swe_slp_time, digits=0)
swe_sen_p <- round(max_swe_sen$p.value, digits=3)
snow_days_yr_count <- sum(sapply(out$duration, function(x) sum(!is.na(x))))
duration_slp_time <- duration_sen$estimates * snow_days_yr_count
duration_sen_slp <- round(duration_slp_time, digits=1)
duration_sen_p <- round(duration_sen$p.value, digits=3)
#create the plot
snow_depth <- ggplot() +
geom_line(data = out,aes(x = winter, y= max_depth), colour="gold3", lwd=0.6) +
geom_point(data = out,aes(x = winter, y= max_depth), colour="gold3", size=2) +
geom_line(data = out,aes(x = winter, y= max_depth_slp), colour="gold3", lwd=0.6) + xlab("")+
ylab("Max. snow depth (cm)")+
theme_bw()+
scale_y_continuous(limits = c(floor((min(out$max_depth)-10)/20)*20, ceiling((max(out$max_depth)+10)/20)*20), expand = c(0,0), breaks=seq(floor((min(out$max_depth)-10)/20)*20,ceiling(max((out$max_depth)+10)/20)*20,20)) +
scale_x_continuous(limits = c(1955, round(max(out$winter),-1)+5), expand = c(0,0), breaks=seq(1955,round(max(out$winter),-1)+5,10)) +
theme(plot.title = element_text(size = 20, face = "bold", hjus=0.04, vjus=-9),
plot.background = element_rect(fill = "transparent"),
plot.margin = unit(c(0,1,0,1), "mm"),
axis.ticks = element_line(colour = "black", size = 0.5),
axis.ticks.length=unit(.25, "cm"),
axis.text.y=element_text(size=15, colour = "black"),
axis.title.y=element_text(size=17, colour = "black", margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.title.x=element_blank(),
axis.text.x=element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(fill=NA, colour = "black", size=1, linetype="solid"),
panel.background = element_rect(fill = "transparent",colour = NA)) +
theme(axis.line = element_blank(), axis.ticks = element_blank())+
geom_text(aes(x=2000, y=150, label=paste0("Snow depth has decreased by ", snow_depth_sen_slp , " cm over ",snow_depth_yr_count," years p = ",snow_depth_sen_p)), color="gold3",size=4.5, col="gold3")
snow_depth
swe_depth <- ggplot() +
geom_line(data = out,aes(x = winter, y= max_swe), colour="darkblue", lwd=0.6) +
geom_point(data = out,aes(x = winter, y= max_swe), colour="darkblue", size=2) +
geom_line(data = out,aes(x = winter, y= max_swe_slp), colour="darkblue", lwd=0.6) + xlab("")+
ylab("Max. SWE (cm)")+
theme_bw()+
scale_y_continuous(limits = c(floor((min(out$max_swe)-2)/5)*5, ceiling((max(out$max_swe)+2)/5)*5), expand = c(0,0), breaks=seq(floor((min(out$max_swe)-2)/5)*5,ceiling((max(out$max_swe)+2)/5)*5,5)) +
scale_x_continuous(limits = c(1955, round(max(out$winter),-1)+5), expand = c(0,0), breaks=seq(1955,round(max(out$winter),-1)+5,10)) +
theme(plot.title = element_text(size = 20, face = "bold", hjus=0.04, vjus=-9),
plot.background = element_rect(fill = "transparent"),
plot.margin = unit(c(0,1,0,1), "mm"),
axis.ticks = element_line(colour = "black", size = 0.5),
axis.ticks.length=unit(.25, "cm"),
axis.text.y=element_text(size=15, colour = "black"),
axis.title.y=element_text(size=17, colour = "black", margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.title.x=element_blank(),
axis.text.x=element_blank(),
legend.background = element_rect(fill = "transparent",colour = NA),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(fill=NA, colour = "black", size=1, linetype="solid"),
panel.background = element_rect(fill = "transparent",colour = NA)) +
geom_text(aes(x=2000, y=38, label=paste0("Snow water has decreased by ", swe_sen_slp , " cm over ",swe_yr_count," years p = ",swe_sen_p)),size=4.5, col="darkblue")
swe_depth
snow_days <- ggplot() +
geom_line(data = out,aes(x = winter, y= duration), colour="darkgray", lwd=0.6) +
geom_point(data = out,aes(x = winter, y= duration), colour="darkgray", size=2) +
geom_line(data = out,aes(x = winter, y= duration_slp), colour="darkgray", lwd=0.6) + xlab("")+
ylab("Snow cover (days)")+
theme_bw()+
scale_y_continuous(limits = c(floor((min(out$duration)-5)/20)*20, ceiling((max(out$duration)+5)/20)*20), expand = c(0,0), breaks=seq(floor((min(out$duration)-5)/20)*20,ceiling((max(out$duration)+5)/20)*20,20)) +
scale_x_continuous(limits = c(1955, round(max(out$winter),-1)+5), expand = c(0,0), breaks=seq(1955,round(max(out$winter),-1)+5,10)) +
theme(plot.title = element_text(size = 20, face = "bold", hjus=0.04, vjus=-9),
plot.background = element_rect(fill = "transparent"),
plot.margin = unit(c(0,1,0,1), "mm"),
axis.ticks = element_line(colour = "black", size = 0.5),
axis.ticks.length=unit(.25, "cm"),
axis.text.y=element_text(size=15, colour = "black"),
axis.title.y=element_text(size=17, colour = "black", margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.text.x=element_text(size=15, colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(fill=NA, colour = "black", size=1, linetype="solid"),
panel.background = element_rect(fill = "transparent",colour = NA) ) +
geom_text(aes(x=2000, y=175, label=paste0("Snow cover has decreased by ", duration_sen_slp , " days over ",snow_days_yr_count," years p = ",duration_sen_p)),size=4.5, col="darkgray")
snow_days
# snow_depth_fixed <- set_panel_size(snow_depth, width  = unit(5, "in"), height = unit(2, "in"))
# swe_depth_fixed <- set_panel_size(swe_depth, width  = unit(5, "in"), height = unit(2, "in"))
# snow_days_fixed <- set_panel_size(snow_days, width  = unit(5, "in"), height = unit(2, "in"))
#
# p1 <- as.grob(snow_depth_fixed)
# p2 <- as.grob(swe_depth_fixed)
# p3 <- as.grob(snow_days_fixed)
#
# top_row <- plot_grid(p1, NULL, p2, NULL, p3, ncol = 1, rel_heights = c(1, -0.3, 1, -0.3, 1), align="hv")
#
# svg("snow_trends.svg", height = 8)
# top_row
# dev.off()
plot1 <- ggplotly(snow_depth)
plot2 <- ggplotly(swe_depth)
plot3 <- ggplotly(snow_days)
# create single plot with 3 panels
plotfinal <- subplot(plot1, plot2,  plot3,
margin=0.05, nrows=3,
shareY=TRUE, shareX=TRUE)
plotfinal
